
<HTML>
<TITLE>A Simple Scene Graph API for OpenGL.</TITLE>
<body text="#B5A642">
<body link="#8FFF8F">
<body vlink="#18A515">
<body alink="#20336B">
<BODY bgcolor="#005000" background="../marble.png">
<H2>Non-class Functions.</H2>
So, with the class functions described above, it is
fairly simple to construct a scene graph. So, now that
you have one, what can you do with it?
<pre>
  void ssgCullAndDraw ( ssgRoot *root ) ;
</pre>
This call deals with the entire process of rendering the database.
Your application need only call ssgInit(), build a database,
create a current context and call ssgCullAndDraw using the root node
of that database.
<H3>Intersection Testing.</H3>
Most applications need to test the scenery to see if moving
objects have collided with it - there are several ways to do
that - but they all share the same mechanisms:
<pre>

int  ssgIsect ( ssgRoot *root, sgSphere *s, sgMat4 m, ssgHit **results ) ;
int  ssgHOT   ( ssgRoot *root, sgVec3    s, sgMat4 m, ssgHit **results ) ;
int  ssgLOS   ( ssgRoot *root, sgVec3    s, sgMat4 m, ssgHit **results ) ;

</pre>
These three calls implement various ways to test the database for collisions,
weapon impacts and such like. In each case, the search for a collision
starts at 'root', and the database is transformed by the matrix 'm'
before the test is evaluated - hence, 'm' is ususally the inverse of
the matrix describing the test object's location.
<ul>
<li>ssgIsect intersects a sphere against the scene.
<li>ssgHOT intersects a vertical line starting at the point 's' (remember,
in SSG, positive Z is 'up'). This is often used to compute
the Height-of-Terrain - hence the name 'HOT'.
<li>ssgLOS intersects an arbitary vector whose direction is defined by 's'.
</ul>
The result in either case is an integer telling
you how many triangles impacted the sphere/vector. If you need to know more
about these intersections, pass the address of a ssgHit * variable as
the last parameter and it will be returned pointing at a STATIC array
of ssgHit structures. Thats a confusing explanation - and an example
will help:
<pre>

ie:

   ssgHit *results ;

   int num_hits = ssgIsect ( root, &sphere, mat, &results ) ;

   for ( int i = 0 ; i < num_hits ; i++ )
   {
     ssgHit *h = &(results [ i ]) ;

     /* Do something with 'h' */
   }

</pre>
Remember, you must finish using the results array before you do
another ssgIsect/ssgHOT/ssgLOS because all three functions share
the same results array.
<p>
An ssgHit looks like this:
<pre>

class ssgHit
{
  ssgLeaf *leaf ;
  int      triangle ;
  sgVec4   plane ;
  sgMat4   matrix ;

  ssgHit ()
  int getNumPathEntries () ;
  ssgEntity *getPathEntry ( int i ) ;
} ;

</pre>
The 'leaf' member points at the leaf node that impacted the sphere.
The 'triangle' member tells you which triangle within the leaf
did the impacting. The 'plane' member contains the plane equation
of the impacting triangle and the 'matrix' element tells you
the net result of concatenating all the transform nodes from
the root to the leaf to the matrix you provided in the ssgIsect call.
<p>
It's possible for there to be multiple paths through the
scene graph to the leaf node. Sometimes you'll need to
look back up the tree to see nodes above the one that we actually
impacted with. Hence, you can read all the ssgEntities that were
traversed on the path from the root down to the leaf.  Calling 
the 'getNumPathEntries' function to find the number of nodes
along the path - and then 'getPathEntry(n)' to get the n'th entry
in the path. The 'root' node will always be the zeroth entry
in the path - and the leaf node will always be the last.
<H3>Lights.</H3>
SSG supports the eight standard OpenGL light sources as class 'ssgLight'.
Since there are only a finite number of these, they all exist all the
time - you just call:
<pre>

  ssgLight *ssgGetLight ( int i ) ;

</pre>
...to get the i'th light should you need to manipulate it.
<pre>

class ssgLight
{
  int isOn () ;
  void on  () ;
  void off () ;
  void setPosition ( sgVec3 pos ) ;
  void setHeadlight ( int head ) ;
  int  isHeadlight () ;
} ;

</pre>
Each light can be turned on or off - or tested to see if it's on or off.
<p>
Lights are positioned with 'setPosition()' - which can be relative
to the origin of the world - or relative to the SSG camera (in 'headlight'
mode).
<H3>Miscellany.</H3>
It's convenient to find out how much texture memory has been
consumed:
<pre>

  int ssgGetNumTexelsLoaded () ;

</pre>
(Bear in mind that a texel could be 16 or 32 bits depending on
the hardware - and with MIPmapping enabled, 25% of the texels
will be in the MIPmaps - so ssgGetNumTexelsLoaded will return
a larger number than the total of the sizes of the input images
might suggest.
<H3>Loading Database Files.</H3>
To load a model file into SSG, you can either call a loader
function that is specific to the format of the file you
wish to load - or you can call 'ssgLoad' - which parses
the filename extension and calls the appropriate format-specific
loader.
<p>
At first, there were only three file loaders:
<ul>
<li> ssgLoadSSG - for '.ssg' files - the 'native' SSG format.
<li> ssgLoadAC  - for '.ac' files - a somewhat obscure format produced
                 by the 'AC3D' modelling tool - reasonably well tried
                 and tested.
<li> ssgLoad3ds - for '.3ds' files as produced by 3DStudio.
</ul>
but in CVS you will also find
<ul>
<li> ssgLoadASE - 3DSMAX ASCII EXPORT Version 2.00, well tested
<li> ssgLoadDXF - AutoCADs famous DXF format. well tested
<li> ssgLoadFLT - OpenFlight
<li> ssgLoadMD2 - Quake MD2
<li> ssgLoadMDL - the format for Micro$ofts Flight simulator, some features
missing, not all models can be loaded (yet)
<li> ssgLoadOBJ - Wavefront, works well
<li> ssgLoadTRI - simple Tri format from "Andy Colbournes Editor".
<li> ssgLoadVRML - Doesn't work at the moment :-(
<li> ssgLoadX - Microsofts DirectX-Format. Most features work.
</ul>

<pre>

  typedef ssgBranch *(*ssgHookFunc)(char *) ;

  ssgEntity *ssgLoad    ( char *fname, ssgHookFunc hookfunc = NULL ) ;

  ssgEntity *ssgLoadSSG ( char *fname, ssgHookFunc hookfunc = NULL ) ;
  ssgEntity *ssgLoadAC  ( char *fname, ssgHookFunc hookfunc = NULL ) ;
  ssgEntity *ssgLoad3ds ( char *fname, ssgHookFunc hookfunc = NULL ) ;

</pre>
Minimally, all you need to do is to call ssgLoadAC/ssgLoad3ds with the
name of the file to load. However, most file formats (AC3D's
and 3Dstudio's included) lack many desirable features, and it is also often
necessary to store application-specific information in the
file.
<p>
SSG's loaders will decode the comment fields found in the
nodes of many common file formats and pass these onto the
application via 'hookfunc'. This function should decode
the string and construct whatever kind of SSG node it
considers appropriate.
<p>
Similarly, the application may wish to embellish the
ssgState of a loaded node - and since state information
rarely has a comment field in most file formats, we
pass the texture filename instead and expect the application
to construct the entire ssgState:
<pre>

  void ssgSetAppStateCallback ( ssgState *(*cb)(char *) ) ;

</pre>
One common problem with file loaders is that it's
often possible to refer to a second file from inside
the first - but the <b>path</b> to that file is often
not adequately defined by the original file. Hence,
the application can specify a file path to be prepended
to all model or texture file names.
<pre>

  void ssgModelPath   ( char *path ) ;
  void ssgTexturePath ( char *path ) ;

</pre>
The texturepath may contain several command characters. For a complete
doc, see the util-library-doc on <code>ulFindFile</code>. Hiere are two examples:
<BR><BR>
$(APOM);$(APOM)/texture;$(APOM)/../texture
<BR><BR>
looks into three directories, seperated by ";". APOM is replaced by the 
actual path the model is in (NOT the path from ssgModelPath!).
If, for example, you are loading your model from /ppe/data/mdl/navion/model, and 
the texture filename is wing.rgb, then plib would look in these places for the file and use
the first one it finds:
<BR><BR>
/ppe/data/mdl/navion/model/wing.rgb
<BR>
/ppe/data/mdl/navion/model/texture/wing.rgb
<BR>
/ppe/data/mdl/navion/texture/wing.rgb
<BR><BR>
Another example: You have all your textures sorted into in a directory-structure 
under /raumplan, then use "/raumplan/$(...)" as ssgTexturePath.

<p>

Some loaders for file formats that use texture formats not 
supported by ssg use this functions to find textures:
<pre>
void ssgFindOptConvertTexture( char * filepath, char * tfname ) 
</pre>
It finds and optionally (= if necessary) converts the texture.
This is only really implemented for Windo$ :-(, for all others it
should just be the two lines you will find in the comment. I didn't
test it, that's the reason I commented it out. But it will warn you
when you have to convert something, so even for non-Windo$-users the
new function is already a step forward.
For the actual conversion, at first I wanted to use GIMP. So, in Deja,
I looked for "+gimp +convert +batch" and similar strings. I found 
several people asking, but almost all the answer were to use
ImageMagick instead. ImageMagick is free as in beer. Also, the docs I
got with the newest gimp is extremely sparse :-(. Therefore, I tried
ImageMagick and this worked straight away. You should find ImageMagick
under
<p>
http://www.wizards.dupont.com/cristy/ImageMagick.html
<p>
Plib uses the ImageMagick application "convert". Since there are other
convert.exe-programs on my computer, I had to copy the ImageMagick
stuff into the directory of my plib-application, so that it uses the correct
convert.exe.
<p>


Most file formats contain considerable numbers of redundant 
nodes (because of the way people build using these tools).
This function walks a database sub-tree multiplying
out any ssgTransform nodes and replacing them with
ssgBranch'ed - unless they have userdata associated with them.
Any branch nodes with zero kids are deleted - any with just
one kid are eliminated and the child node pushed up one level.
<pre>

  void ssgFlatten ( ssgEntity *ent ) ;

</pre>
It's important for 3D performance to optimise
triangles into triangle strips or fans. Since most
file formats don't record strip/fan information,
it's useful to call:
<pre>

  void ssgStripify ( ssgEntity *ent ) ;

</pre>
<H3>Saving Database Files.</H3>
Most SSG programs will simply load a file and display it in
some way - but occasionally, it's useful to be able to write
a file back out again.
<p>
To write a model file from SSG, you can either call a writer
function that is specific to the format of the file you
wish to save - or you can call 'ssgSave' - which parses
the filename extension and calls the appropriate format-specific
writer.
<p>
Saving into ssg-format is done with these functions:
<ul>
<li> ssgSaveSSG - for '.ssg' files - the 'native' SSG format.
</ul>
<pre>

  int ssgSave    ( char *fname, ssgEntity *ent ) ;
  int ssgSaveSSG ( char *fname, ssgEntity *ent ) ;

</pre>
This returns TRUE if the operation worked - FALSE if it failed.
In the newest version from cvs, you will also find writers for the
AC, ASE, DXF, OBJ and TRI-formats.
<hr>
<table width="100%">
   	<tr>
   		<td width="33%" align="left"><a href="ssgContext.html">&lt;= previous =</a></td>
   		<td width="34%" align="center"><a href="index.html">Return to SSG Index</a></td>
   		<td width="33%" align="right"><a href="LoaderWriter.html">= next =&gt;</a></td>
   	</tr>
</table>
<hr>
<ADDRESS>
<A HREF="http://web2.airmail.net/sjbaker1">
Steve J. Baker.</A>
&lt;<A HREF="mailto:sjbaker1@airmail.net">sjbaker1@airmail.net</A>&gt;
</ADDRESS>
</BODY>
</HTML>

