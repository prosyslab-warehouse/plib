<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (Win98; U) [Netscape]">
   <title>The Picoscopic User Interface: Programmers Guide.</title>
</head>
<body text="#B5A642" bgcolor="#005000" link="#8FFF8F" vlink="#18A515" alink="#20336B" background="../marble.png">
 
<table>
<tr>
<td>
<center><img SRC="pooh.png" ALT="Imagine Pooh Here" ></center>
</td>

<td>
<center>
<h1>
PUI: A Picoscopic User Interface</h1></center>

<center>
<h1>
Programmers Guide.</h1></center>

<center>By Steve Baker</center>
</td>
</tr>
</table>

<h2>
Introduction</h2>
The Picoscopic User Interface (PUI - pronounced '<a href="http://worldkids.net/pooh/pooh01.html">pooh</a>ey')
is a simple set of C++ classes that allow programs written in GLUT and
OpenGL to create buttons, sliders, menus etc.
<p>

PUI is now a part of <a href="../index.html">PLIB</a>.
<p>

The PUI FAQ list is <a href="FAQ.html">here</a>.
<p>

Like most similar GUI's (MUI, Xforms, FLTK, GLUI, etc), PUI is comprised
of a base class (puObject) from which all the interesting widgets are derived.
Most of the packages functionality is concentrated in the puObject class.
<h2>
Contributions</h2>
<a href="mailto:mdanks@Stormfront.com">Mark Danks</a> contributed code for making PUI run without GLUT under Win32,
<p>

<a href="mailto:shammi@bu.edu">AbdulWajid Mohamed</a> added the 'PUSTYLE_SHADED' and 'PUSTYLE_SMALL_SHADED' code.
He also fixed a number of bug fixes.
<p>

Dave McClurg added the puListBox and puFilePicker widgets.
<p>

John Fay added a few widgets and other things and reworked this
document.
<h2>
A Truly PUI API:</h2>
Here are the elements that make up the PUI API:
<table>
<tr>
<td>
<h3>
Classes:</h3>
</td>

<td></td>

<td>
<h3>
Non-class functions:</h3>
</td>
</tr>

<tr>
<td>
<ul>
  <li>  <a href="#puFont">puFont</a>  </li> 
  <li>  <a href="#puButton">puButton</a>  </li> 
  <li>  <a href="#puArrowButton">puArrowButton</a>  </li> 
  <li>  <a href="#puOneShot">puOneShot</a>  </li> 
  <li> <a href="#puDial">puDial</a></li> 
  <li>  <a href="#puSlider">puSlider</a>  </li> 
  <li> <a href="#puBiSlider">puBiSlider</a></li> 
  <li> <a href="#puTriSlider">puTriSlider</a></li> 
  <li>  <a href="#puFrame">puFrame</a>  </li> 
  <li>  <a href="#puText">puText</a>  </li> 
  <li>  <a href="#puInput">puInput</a>  </li>
</ul>
</td>

<td>
<ul>
  <li> <a href="#puLargeInput">puLargeInput</a></li> 
  <li>  <a href="#puGroup">puGroup</a>  </li> 
  <li>  <a href="#puInterface">puInterface</a>  </li> 
  <li>  <a href="#puButtonBox">puButtonBox</a>  </li> 
  <li>  <a href="#puPopup">puPopup</a>  </li> 
  <li>  <a href="#puDialogBox">puDialogBox</a>  </li> 
  <li>  <a href="#puPopupMenu">puPopupMenu</a>  </li> 
  <li>  <a href="#puMenuBar">puMenuBar</a>  </li> 
  <li> <a href="#puVerticalMenu">puVerticalMenu</a></li> 
  <li> <a href="#puListBox">puListBox</a></li> 
  <li>  <a href="#puFileSelector">puFileSelector</a>  </li>
  <li>  <a href="#puFilePicker">puFilePicker</a>  </li>
</ul>
</td>

<td>
<ul>
  <li>  <a href="#puSetDefaults">puSetDefault*</a>  </li> 
  <li>  <a href="#puInit">puInit</a>  </li> 
  <li>  <a href="#puDisplay">puDisplay</a>  </li> 
  <li>  <a href="#puDeleteObject">puDeleteObject</a>  </li>
  <li>  <a href="#puKeyboard">puKeyboard</a>  </li> 
  <li>  <a href="#puMouse">puMouse</a>  </li> 
  <li>  <a href="#puShowCursor">puShowCursor</a>  </li> 
  <li>  <a href="#ActiveWidgetFunctions">puActiveWidget</a>  </li> 
  <li>  <a href="#CutAndPaste">Cutting and Pasting</a> </li>
</ul>
</td>
</tr>
</table>

<h2> Note:</h2>

In the description of each widget class below, there is a small
screenshot of one example of that widget.  You can see the code
used to generate those screenshots in the PLIB example program
<code>widget_list.cxx</code>.  However, by changing the rendering
style, you can make them look considerably different from this.
<h2> PUI Terminology.</h2>
Some terminology:
<ul>
<li>
WIDGET : A single graphic user interface entity such as a button, slider,
menu or some kind of decorative entity like a border or information string.</li>

<li>
LEGEND : This is a text string that resides inside the widget's active
area.</li>

<li>
LABEL : This is a text string that resudes outside the widget's active
area.</li>

<li>
VALUE : All puObjects have a current 'value' which can be read or written
as an integer, float or string. The exact meaning of this value may vary
from widget to widget. For some widget types, the value has no meaning
at all (eg a puFrame) - although it is always available to be set and read
by the application. The manner in which the value of a widget is displayed
(if at all) varies from widget to widget.</li>

<li>
ABOX : The Activity Box - A rectangular region that is the 'active' area
into which mouse clicks must be directed in order to make a widget do whatever
it does.</li>

<li>
BBOX : The Bounding Box - A rectangular region that surrounds the pixels
drawn by the widget. This is typically the ABOX - extended in one direction
to include the LABEL string.</li>

<li>
STRING : PUI recognizes only the printable ASCII set plus space and newline.</li>
</ul>

<h2>
Hello World in PUI.</h2>

<table>
<tr>
<td>Here is a simple example program. It pops up a window with a single
button widget that prints 'Hello World.' to stdout when you click it. (This
program is in the PUI examples directory as 'simple.cxx').</td>

<td><img SRC="simple.png" ALT="Simple PUI example"></td>
</tr>
</table>

<pre>#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#ifdef WIN32
#include &lt;windows.h>
#else
#include &lt;unistd.h>
#endif
#include &lt;math.h>
#include &lt;GL/glut.h>
#include &lt;plib/pu.h>

void motionfn ( int x, int y )
{
  <a href="#puMouse">puMouse ( x, y ) ;
</a>  glutPostRedisplay () ;
}

void mousefn ( int button, int updown, int x, int y )
{
  <a href="#puMouse">puMouse ( button, updown, x, y ) ;
</a>  glutPostRedisplay () ;
}

void displayfn ()
{
  glClearColor ( 0.1, 0.4, 0.1, 1.0 ) ;
  glClear      ( GL_COLOR_BUFFER_BIT ) ;

  <a href="#puDisplay">puDisplay () ;

</a>  glutSwapBuffers   () ;
  glutPostRedisplay () ;
}

void button_cb ( puObject * )
{
  fprintf ( stderr, "Hello World.\n" ) ;
}
 

int main ( int argc, char **argv )
{
  glutInitWindowSize  ( 240, 120 ) ;
  glutInit            ( &amp;argc, argv ) ;
  glutInitDisplayMode ( GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH ) ;
  glutCreateWindow    ( "PUI Application"  ) ;
  glutDisplayFunc     ( displayfn ) ;
  glutMouseFunc       ( mousefn   ) ;
  glutMotionFunc      ( motionfn  ) ;

  <a href="#puInit">puInit () ;

</a>  <a href="#puOneShot">puOneShot *b = new puOneShot ( 50, 50, 200, 80 ) ;

  b -> setLegend   ( "Say Hello" ) ;
  b -> setCallback ( button_cb ) ;

</a>  glutMainLoop () ;

  return 0 ;
}</pre>
Notice that the program uses a pretty conventional GLUT startup sequence,
with the usual callbacks for mouse events and redisplay. You can even continue
to use GLUT popup menus which will work quite happily in conjunction with
PUI menus.
<p>

The needs of PUI are small - as a minimum, call the <a href="#puMouse">puMouse</a>
function whenever the mouse is clicked or dragged, call the puKeyboard
function whenever a key is pressed, call the <a href="#puDisplay">puDisplay</a>
function frequently enough to maintain smooth interactions.
<p>
The creation of the user interface is similarly simple, calling the
constructor function for the objects you need (with the dimensions of the
active area of each object) - then add labels, legends, callback functions,
etc.
<p>
Whenever the <a href="#puMouse">puMouse</a> function detects that the
mouse coordinate lies over an active widget, it calls the user-supplied
callback function and takes the necessary actions to update the graphics
on the next call to <a href="#puDisplay">puDisplay</a>.
<h2>
Multiple Windows in PUI</h2>
When you create a new widget, PUI places it in the current GLUT window. 
If the your application opens multiple windows, you can place user interface
widgets in any window you please.  The widget coordinates are calculated
from the lower left-hand corner of the window.  There are a few recommended
practices when using PUI in connection with multiple windows:
<ul>
<li>
Make the first widget in a new window a "puGroup" widget and place all
of that window's widgets in that group.  This is simply good organization.</li>

<li>
Do not place widgets that are displayed in one window under a "puGroup"
widget that is displayed in another window.  PUI has a "puDisplay"
function that will redraw only the widgets in a single window, but it does
not work if widgets in one window are part of another window's group.</li>

<li>
If the user will be able to reshape the window, include a window reshape
function that adjusts the positions and sizes of the widgets.  If
the user should not resize the window then the window reshape function
should reset the window to its original size.</li>

<li>
Note that you can let the <a href="#puDisplay">puDisplay</a> function
only redraw the widgets in a particular window, which is especially
useful if you use the same display callback for multiple windows.</li>
</ul>
 
<table>
<tr>
<td>This is a more complicated example in the PUI example directory called
'complex.cxx', it produces a menu and a button that float in front of a
tumbling cube that is rendered in OpenGL.  In a second window are
two sliders which allow the user to control the speed and direction of
the cube's rotation.  A third window contains a bi-slider and a tri-slider
which truncate the cube in two directions.</td>

<td><img SRC="complex.png" ALT="Complex PUI example"></td>
</tr>
</table>

<h2>
Object Picking</h2>
The most recent widget to be activated is called the "active widget." 
Usually if you click the mouse on another widget the active widget immediately
deactivates and the new widget becomes the active widget.  There are
times, however, when you will want to click the mouse somewhere in a window
and have the active widget operate on where you clicked the mouse. 
You do this by setting and invoking the widget's "active callback." 
A simple GLUT mouse function that does this is as follows:
<pre>
  static void mousefn ( int button, int updown, int x, int y )
  {
    if ( !puMouse ( button, updown, x, y ) )
    {
      // PUI didn't take the mouseclick, try the main window
      mouse_x = x ;
      mouse_y = puGetWindowHeight () - y ;
      // Check for an active widget.
      //  If there is one, call its active callback
      if ( puActiveWidget () )
        puActiveWidget () -> invokeActiveCallback () ;
   }

   glutPostRedisplay () ;
 }
</pre>
First the mouse function calls "puMouse" to see if the user clicked
on a new PUI widget.  If the user did not, "puMouse" returns FALSE
and the function executes the contents of the if-block.  It saves
the mouse coordinates in a pair of global variables and, if there is an
active widget, it invokes the active widget's active callback.  This
active callback will invoke the OpenGL select mode, create the pick matrix,
and redraw the window to get the selected objects.  The PUI examples
directory has a program, "PointPicker", which does this.
<h2>
Transparent GUI's</h2>
One very trendy idea is to use translucent GUI widgets. This is handy because
the GUI doesn't intrude quite so badly into the available screen area.
Translucent menus have always been possible in PUI - it's just that nobody
ever actually wanted to do it. Here's what you do:
<ul>
<li>
Pick a default colour with an alpha component of about 0.4f.</li>

<li>
Be sure to glEnable(GL_BLEND) and set up the appropriate blend functions.
I use glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) and glAlphaFunc(GL_GREATER,0.1f)
- call these just before puDisplay().</li>

<li>
Now, is that cool or what?</li>
</ul>

<h2>
Class Descriptions</h2>
<a NAME="puFont"></a>
<h3>
puFont</h3>
A puFont is a simple class which can be constructed in one of two ways:
<h4>
A GLUT Font.</h4>

<pre>  puFont::puFont ( void *glut_font ) ;

</pre>
Where 'glut_font' is GLUT_BITMAP font. Since there are only seven GLUT_BITMAP
fonts, these have all been pre-declared within PUI (mainly for backwards
compatability with PLIB versions before 1.0.7).
<pre>  extern puFont PUFONT_8_BY_13 ;        - 8x13 Fixed width
  extern puFont PUFONT_9_BY_15 ;        - 9x15 Fixed width
  extern puFont PUFONT_TIMES_ROMAN_10 ; - 10-point Proportional
  extern puFont PUFONT_TIMES_ROMAN_24 ; - 24-point Proportional
  extern puFont PUFONT_HELVETICA_10 ;   - 10-point Proportional
  extern puFont PUFONT_HELVETICA_12 ;   - 12-point Proportional
  extern puFont PUFONT_HELVETICA_18 ;   - 18-point Proportional

</pre>
These are light on storage - but slow to render on most hardware-based
OpenGL implementations because GLUT uses glBitMap to render its glyphs.
If you wish to use PLIB on a software-only OpenGL implementation (Good
Luck!) then you'll want to use these GLUT fonts since glBitMap is usually
faster than texture-mapped text.
<h4>
Using a pre-built FNT font</h4>

<pre>  puFont::puFont ( fntTexFont *tex_font,
                   float pointsize, float slant = 0 ) ;

</pre>
Where 'tex_font' is texture-based font created using the
<a href="../fnt/index.html">FNT
library</a> and setting the pointsize and optional italic slant (both measured
in pixels).
<a NAME="puObject"></a>
<h3>
puObject</h3>
All PUI widgets are derived from the puObject abstract base class. User
programs should never declare objects of this type. puObjects are in turn
derived from an internally defined puValue class - but this is never visible
to the user and is not documented here.
<p>
When you declare most widgets, you must define the size of ABOX for
the widget. (This is actually the pixel coordinates of the rectangle around
the active area of the widget - with the origin at bottom-left of the window).
<pre>   puObject::puObject ( int minx, int miny, int maxx, int maxy ) ;

</pre>
(Some widgets need more or fewer arguments to their constructor - but most
follow this scheme).
<p>
You can always find the type of an object derived from puObject by calling:
<pre>  int puObject::getType() ;

</pre>
This returns a bitmask showing the inheritance of any object derived from
the puObject base class:
<pre>  #define PUCLASS_VALUE
  #define PUCLASS_OBJECT
  #define PUCLASS_GROUP
  #define PUCLASS_INTERFACE
  #define PUCLASS_FRAME
  #define PUCLASS_TEXT
  #define PUCLASS_BUTTON
  #define PUCLASS_ONESHOT
  #define PUCLASS_POPUP
  #define PUCLASS_POPUPMENU
  #define PUCLASS_MENUBAR
  #define PUCLASS_INPUT
  #define PUCLASS_BUTTONBOX
  #define PUCLASS_SLIDER
  #define PUCLASS_DIALOGBOX
  #define PUCLASS_ARROW
  #define PUCLASS_LISTBOX
  #define PUCLASS_DIAL
  #define PUCLASS_FILEPICKER
  #define PUCLASS_FILESELECTOR
  #define PUCLASS_BISLIDER
  #define PUCLASS_TRISLIDER
  #define PUCLASS_VERTMENU
  #define PUCLASS_LARGEINPUT

</pre>
Hence, if you declare an object of (say) class puOneShot, then calling
getType() for that object would return
<pre>   PUCLASS_VALUE | PUCLASS_OBJECT | PUCLASS_BUTTON | PUCLASS_ONESHOT</pre>
(since a puOneShot is a kind of puButton which is a kind of puObject which
is [although not documented that way here] a kind of puValue).
<p>
For the purposes of printing diagnostics, etc there is also:
<pre>  char *puObject::getTypeString() ;

</pre>
...which returns a pointer to a statically allocated string which is the
name of the top-level class to which that object belongs.
<pre>   struct puBox { int min[2] ; int max[2] ; }

   puBox *puObject::getABox () ;
   puBox *puObject::getBBox () ;

</pre>
get the ABOX (Activity Box) and BBOX (Bounding Box) of the object.
<p>
You can also move or resize the ABOX of a widget after it has been declared
using:
<pre>  void puObject::setPosition ( int x, int y ) ;
  void puObject::setSize     ( int w, int h ) ;

  void puObject::getPosition ( int *x, int *y ) ;
  void puObject::getSize     ( int *w, int *h ) ;</pre>
The bounding box is adjusted to fit around tha activity box and the label,
if any.
<p>
<a NAME="getValue"></a>The following functions allow you to manipulate
the value of the widget:
<pre>  void  puObject::clrValue () ;
  void  puObject::setValue ( int   i ) ;
  void  puObject::setValue ( float f ) ;
  void  puObject::setValue ( char *s ) ;

  void  puObject::getValue ( int   *i ) ;
  void  puObject::getValue ( float *f ) ;
  void  puObject::getValue ( char  *s ) ;  /* copies the string value into the string that is passed in */
  void  puObject::getValue ( char **s ) ;  /* sets the argument to point to the string value */
  int   puObject::getValue () ;
  float puObject::getFloatValue  () ;
  char  puObject::getCharValue   () ;      /* returns the first character in the string value */
  char *puObject::getStringValue () ;

</pre>
The clrvalue() function has the special function of setting the string
value of the widget to the empty string - and the numeric parts to zero.
<p>
Some kinds of widget have a default value that they can easily be reset
to.
<pre>  void puObject::defaultValue() ;

</pre>
...allows you to return the widget to some known default value. The default
value can also be set and read:
<pre>  void puObject::setDefaultValue ( int    i ) ;
  void puObject::setDefaultValue ( float  f ) ;
  void puObject::setDefaultValue ( char  *s ) ;

  void puObject::getDefaultValue ( int   *i ) ;
  void puObject::getDefaultValue ( float *f ) ;
  void puObject::getDefaultValue ( char **s ) ;
  int  puObject::getDefaultValue () ;

</pre>
There are many occasions when you'd really like to have the PUI widget
directly drive and/or reflect the value of some memory location in the
application code. These calls let you do that:
<pre>  void puObject::setValuator ( int   *i ) ;
  void puObject::setValuator ( float *f ) ;
  void puObject::setValuator ( char  *s ) ;

</pre>
Once you make one of these calls, PUI will automatically update the memory
location indicated with the current value of the widget whenever it changes
- and also update the appearance of the widget to reflect the value stored
in that memory location whenever the widget is redrawn. This is often a
lot more convenient than using a callback function to register changes
in the widget's value.
<p>
IMPORTANT NOTE: When you pass a 'char*' to setValuator, it is your responsibility
to ensure that this pointer is pointing at enough memory to store the longest
possible string that this widget can possibly need.  The string in
the puValue class is defined as being PUSTRING_MAX characters long; currently
this is 80.
<p>
Passing NULL to setValuator causes PUI to revert to using an internal
variable to store the widget's state.
<p>
Each widget can also retain a pointer to user-supplied data:
<pre>  void  puObject::setUserData ( void *data ) ;
  void *puObject::getUserData () ;</pre>
When the widget is drawn, the application has control of the drawing style
and the colours in which the widget is drawn. Reasonable defaults are provided
by PUI if you don't set them:
<pre>  void puObject::setStyle ( int style ) ;
  int  puObject::getStyle () ;

  'style' is one of:
      PUSTYLE_NONE
      PUSTYLE_PLAIN
      PUSTYLE_SHADED          -- This is the Default.
      PUSTYLE_SMALL_SHADED
      PUSTYLE_BEVELLED
      PUSTYLE_SMALL_BEVELLED
      PUSTYLE_BOXED
      PUSTYLE_SPECIAL_UNDERLINED
      PUSTYLE_DROPSHADOW
      PUSTYLE_RADIO</pre>
The various styles are interpreted as follows:
<ul>
<li>
PUSTYLE_NONE - No background is drawn for the widget - just the legend
and the label.</li>

<li>
PUSTYLE_PLAIN - Just a plain solid-coloured rectangle.</li>

<li>
PUSTYLE_BEVELLED - The widget is drawn with a three-dimensional-looking
bevelled edge around it - with the 'light' shining on it from the top left.</li>

<li>
PUSTYLE_SMALL_BEVELLED - Same as for PUSTYLE_BEVELLED but with a smaller
border.</li>

<li>
PUSTYLE_SHADED - Similar to PUSTYLE_BEVELLED - but with the main rectangle
counter-shaded.</li>

<li>
PUSTYLE_SMALL_SHADED - Same as for PUSTYLE_SHADED but with a smaller border.</li>

<li>
PUSTYLE_BOXED - A simple rectangle with a line around the outside.</li>

<li>
PUSTYLE_SPECIAL_UNDERLINED - A simple rectangle drawn with a thin line
at the bottom, giving an "underlined" effect like you can see in the
<a href="#puMenuBar">puMenuBar</a> and <a href="#puVerticalMenu">puVerticalMenu</a> widgets.</li>

<li>
PUSTYLE_DROPSHADOW - A simple rectangle - but drawn with a shadow below
and to the right to make it look like it has been raised off of the page.</li>

<li>
PUSTYLE_RADIO - The bounding rectangle and the legend text isn't drawn
at all - the widget is drawn as a small diamond shape which is filled in
when the object has a non-zero value. This is only useful for puButton
widgets.</li>
</ul>
In case of PUSTYLE_BOXED and PUSTYLE_SPECIAL_UNDERLINED, you can alter
the thickness of the border around the widget / the width of the line
at the bottom of the widget or retrieve the current value:
<pre>

  void puObject::setBorderThickness ( int t ) ;
  int  puObject::getBorderThickness ( void ) ;

</pre>
By default, a border thickness of two pixels is used in PUSTYLE_BOXED.
For PUSTYLE_SPECIAL_UNDERLINED, a one pixel wide line is drawn.
<p>
But please ensure only to call the setBorderThickness routine <b>after</b>
specifying the widget's style, because the setStyle function sets the
border thickness automatically according to the (different) default
values for PUSTYLE_BOXED and PUSTYLE_SPECIAL_UNDERLINED. Thus, the border
width which you have set would be overridden.
<p>
In addition, you can use the negation of the style to swap the appearance
of the selected and deselected versions of an object. Hence, using a style
of -PUSTYLE_BEVELLED will produce a widget that appears to be pressed in
when its value is zero and popped out when it's value is non-zero.
<p>
Whilst most widgets default to a style of PUSTYLE_SHADED, some of the
more complex types such as sliders and menu's pick more complex defaults
in order to look 'reasonable'. You can still override those defaults -
but the results can often be less than desirable.
<pre>

 void puObject::setColour ( int which, float  r, float g, float  b, float  a = 1.0f ) ;
 void puObject::getColour ( int which, float *r, float *g, float *b, float *a = NULL ) ;

  'which' is one of:
      PUCOL_FOREGROUND
      PUCOL_BACKGROUND
      PUCOL_HIGHLIGHT
      PUCOL_LABEL
      PUCOL_LEGEND

</pre>
Picking all of the individual colours for each widget can be tedious,
so there is a handy function that sets a 'theme' colour for the widget
and then picks suitable colours near to that theme for the other colours
of the widget. This function works well enough that you will almost never
need to set the colours individually.
<pre>

  void puObject::setColourScheme ( float r, float g, float b, float a = 1.0f ) ;

</pre>
Please note that these routines only affect the appearance of the widget
itself in case of widgets that contain subwidgets (currently <a href="#puDialogBox">puDialogBox</a>,
<a href="#puFileSelector">puFileSelector</a>, <a href="#puLargeInput">puLargeInput</a>, <a href="#puMenuBar">puMenuBar</a>, <a href="#puPopup">puPopup</a>, <a href="#puPopupMenu">puPopupMenu</a>,
<a href="#puVerticalMenu">puVerticalMenu</a> and the obsolete <a href="#puFilePicker">puFilePicker</a> class).
<p>
However, these classes are all derived directly or indirectly from
<a href="#puGroup">puGroup</a>, and thus you can use the appropiate <a href="#puGroup">puGroup</a> functions in
order to change the styles, colours or border thicknesses of the
subwidgets.
<p>
In addition to the pre-defined styles, PUI allows you to create his
own drawing function and save the related drawing data.  This is done
by means of the "render data" and "render callback."  A render callback
is a user-defined function that has the following definition:
<pre>

  typedef void (*puRenderCallback)(class puObject *, int dx, int dy, void *) ;

</pre>
The function takes four parameters:  a pointer to the object whose
render callback this is, the x- and y-coordinates of the lower left-hand
of the widget, and a pointer to your render data.  The user tells
PUI to use his rendering callback instead of the usual drawing function
by invoking the following function:
<pre>  void puObject::setRenderCallback ( puRenderCallback *c, void *d = NULL ) ;</pre>
The two arguments are the name of the render callback and an optional pointer
to the user-defined render data. If a render callback exists, the widget's
draw function renders only the activity box (unless PUSTYLE_NONE is used)
and the label (if you specifed one) and calls the render callback
afterwards instead of executing the code which would normally be used
to draw the widget.
<p>
PUI also has functions to allow the user to retrieve and invoke the
render callback:
<pre>

  puRenderCallback puObject::getRenderCallback ( void ) ;
  void      *puObject::getRenderCallbackData ( void ) ;
  void       puObject::invokeRenderCallback ( int dx, int dy ) ;

</pre>
<p>
When a widget is activated, its user-supplied callback function is called
(if it exists):
<pre>

  typedef void (*puCallback)(puObject *) ;
 
  void       puObject::setCallback ( puCallback c ) ;
  puCallback puObject::getCallback () ;
  void       puObject::invokeCallback () ;

</pre>
The callback is invoked (typically) when the user releases the left mouse
button when the cursor lies within the widget's active area. The user-supplied
function is called with the address of the widget as a parameter so that
the same callback can oftem be used with a variety of similar widgets.
It is also possible to invoke an object's callback explicitly using invokeCallback
- bear in mind that this does not change the value of the object - unless
the callback itself does so.
<p>
There are occasionally times when you'd like the widget to be activated
when the user PRESSES the mouse button instead of when he RELEASES it (which
is the default). PUI lets you make widgets that are activated on both button-down
<b>and</b> button up. You can even tell PUI to call your callback continually
all the time the left button is pushed while the cursor is inside the widget:
<pre>

  void puObject::setActiveDirn ( int dirn ) ;
  int  puObject::getActiveDirn () ;

  where:
    'dirn' is either PU_UP, PU_DOWN, PU_CONTINUAL or PU_UP_AND_DOWN.

</pre>
As discussed earlier, PUI tracks the most recently invoked widget
and calls it the "active widget."  PUI allows you to define a callback
to be invoked for the active widget when the user clicks the mouse outside
any user interface widgets.  You can also define a callback for PUI
to call when the widget is being deactivated, when the user is activating
another widget.  The following functions do these things:
<pre>

  void       puObject::setActiveCallback ( puCallback c ) ;
  puCallback puObject::getActiveCallback ( void ) ;
  void       puObject::invokeActiveCallback ( void ) ;

  void       puObject::setDownCallback ( puCallback c ) ;
  puCallback puObject::getDownCallback ( void ) ;
  virtual void puObject::invokeDownCallback ( void ) ;

</pre>
 
Most widgets can have a LEGEND (text inside the active area of the widget),
and also a LABEL (text outside the active area). The application gets to
choose where the LABEL is placed relative to the active area of the widget. 
You can also move the LEGEND text around inside the widget.
<pre>

  void   puObject::setLegend ( char *str ) ;
  void   puObject::setLabel  ( char *str ) ;

  char  *puObject::getLegend () ;
  char  *puObject::getLabel  () ;

  void   puObject::setLegendFont ( puFont font ) ;
  void   puObject::setLabelFont  ( puFont font ) ;

  puFont puObject::getLegendFont () ;
  puFont puObject::getLabelFont  () ;

  void  puObject::setLabelPlace ( int place ) ;
  int   puObject::getLabelPlace () ;

  where 'place' is one of:
</pre>

<table width="100%">
<tr><td>
<pre>
      PUPLACE_ABOVE_LEFT
      PUPLACE_ABOVE_RIGHT

      PUPLACE_TOP_LEFT
      PUPLACE_TOP_CENTERED
      PUPLACE_TOP_RIGHT

      PUPLACE_UPPER_LEFT
      PUPLACE_UPPER_RIGHT

      PUPLACE_CENTERED_LEFT
      PUPLACE_CENTERED_RIGHT

      PUPLACE_LOWER_LEFT
      PUPLACE_LOWER_RIGHT    -- The default LABEL place

      PUPLACE_BOTTOM_LEFT
      PUPLACE_BOTTOM_CENTERED
      PUPLACE_BOTTOM_RIGHT

      PUPLACE_BELOW_LEFT
      PUPLACE_BELOW_RIGHT
</pre>
</td></tr>

<tr><td>
<img SRC="labelplaces.png" ALT="Illustration of label places" height=154 width=680 align=RIGHT>
</td></tr>
</table>

<pre>
  void  puObject::setLegendPlace ( int place ) ;
  int   puObject::getLegendPlace () ;

  where 'place' is one of:
</pre>

<table width="100%">
<tr><td>
<pre>
      PUPLACE_TOP_LEFT
      PUPLACE_TOP_CENTERED
      PUPLACE_TOP_RIGHT

      PUPLACE_CENTERED_LEFT
      PUPLACE_CENTERED_CENTERED    -- The default LEGEND place.
      PUPLACE_CENTERED_RIGHT

      PUPLACE_BOTTOM_LEFT
      PUPLACE_BOTTOM_CENTERED
      PUPLACE_BOTTOM_RIGHT
</pre>
</td></tr>

<tr><td>
<img SRC="legendplaces.png" ALT="Illustration of legend places" align=RIGHT>
</td></tr>
</table>

<p>
Each widget can be hidden (so it isn't drawn - and can't be clicked
on), or simply 'greyed out' (so it can't be clicked on even though it's
drawn - but in a style that makes it clear that this is the case).
<pre>

  void puObject::greyOut    () ;
  void puObject::activate   () ;  -- Undo the 'greyout' effect
  int  puObject::isActive   () ;

  void puObject::hide       () ;
  void puObject::reveal     () ;  -- Undo the 'hide' effect
  int  puObject::isVisible  () ;

</pre>
If you want to see or change which window a widget is drawn in,
you use the following functions:
<pre>

  void  puObject::setWindow ( int w ) ;
  int   puObject::getWindow () ;

</pre>
If you have some generic data that your widget needs but that doesn't
fit anywhere else, you can save it in the widget's "user data" entry:
<pre>

  void  puObject::setUserData ( void *data ) ;
  void *puObject::getUserData ( void ) ;

</pre>
Finally, an object can be made to react to the 'return' key on the
keyboard just as if it had been clicked with the mouse.
<pre>

   void puObject::makeReturnDefault ( int boolean ) ;
   int  puObject::isReturnDefault   () ;

</pre>
In general, it is very confusing to the user to have multiple objects set
up with ReturnDefault enabled (although PUI allows this). Typically, this
option is only used on buttons in simple Yes/No dialog boxes.
<a NAME="puButton"></a>
<h3>
puButton</h3>
<img SRC="puButton.png" ALT="View of puButton widget" BORDER=0 height=127 width=188 align=RIGHT>The
puButton class is derived from <a href="#puObject">puObject</a>. It implements
a simple push-button widget. When clicked its value alternates from '0'
to '1' and is highlighted graphically when in the '1' state. By default,
buttons 'latch' down when clicked. The application could change this to
a one-shot behaviour by resetting the value to '0' in the buttons callback
(although it is a lot more convenient to simply use the <a href="#puOneShot">puOneShot</a>
class for this).
<pre>

  puButton::puButton ( int minx, int miny, char *legend ) ;
  puButton::puButton ( int minx, int miny, int maxx, int maxy ) ;

</pre>
Apart from these convenient short-hand constructor functions, puButtons
have no special API - everything they need is in the <a href="#puObject">puObject</a>
API.
<a NAME="puArrowButton"></a>
<h3>
puArrowButton</h3>
<img SRC="puArrowButton.png" ALT="View of puArrowButton widget" height=127 width=188 align=RIGHT>The
puArrowButton class is derived from <a href="#puButton">puButton</a>. The
only difference is that puArrowButton renders as an arrow rather than as
a rectangular button.
<pre>

  puArrowButton::puArrowButton ( int minx, int miny, int maxx, int maxy,
                                 int arrow_type ) :

Where 'arrow_type' is one of:
Single arrows:

  PUARROW_UP
  PUARROW_DOWN
  PUARROW_LEFT
  PUARROW_RIGHT

Double arrows:

  PUARROW_FASTUP
  PUARROW_FASTDOWN
  PUARROW_FASTLEFT
  PUARROW_FASTRIGHT

</pre>
In addition, you can get/set the direction of the arrow in mid-run:
<pre>

  int  puArrowButton::getArrowType ( void  ) ;
  void puArrowButton::setArrowType ( int i ) ;

</pre>
<a NAME="puOneShot"></a>
<h3>
puOneShot</h3>
<img SRC="puOneShot.png" ALT="view of puOneShot widget" height=127 width=188 align=RIGHT>The
puOneShot class is derived from <a href="#puButton">puButton</a>. It implements
a simple push-button widget which automatically pops back out again as
soon as the mouse is released. This means that it's value is always '1'
inside the callback function and '0' at all other times.
<p>

puOneShot's have no special API - everything they need is in the <a href="#puButton">puButton</a>
API.
<a NAME="puSlider"></a>
<h3>
puSlider</h3>
<img SRC="puSlider.png" ALT="view of puSlider widget" height=127 width=188 align=RIGHT>The
puSlider class is derived from
<a href="#puObject">puObject</a>. It implements
a slider widget. When clicked, dragged or unclicked its value changes in
proportion to where it is clicked. For the value (as returned by
 <a href="#puObject">puObject</a>::getValue(float
*f)  ) ranges from 0.0 to 1.0 from the left to the right (or from the
bottom to the top). The application can change the position of the slider
using  <a href="#puObject">puObject</a>::setValue(float f)  with
a number in the range 0.0 to 1.0.
<pre>

  puSlider::puSlider ( int minx, int miny, int sz ) :
  puSlider::puSlider ( int minx, int miny, int sz, TRUE ) :
  puSlider::puSlider ( int minx, int miny, int sz, {TRUE|FALSE}, int width ) ;

</pre>
The first version produces a HORIZONTAL slider, the second version produces
a VERTICAL slider.  The third version produces a slider with a non-default
width.
<pre>

  void  puSlider::setSliderFraction ( float f ) ;
  float puSlider::getSliderFraction () ;

</pre>
The 'slider fraction' is the proportion of the total width of the slider
widget that is taken up with the sliders' "handle". It defaults to 0.1
(ie one tenth of the width of the entire widget).
<p>
There are several choices to be made relating to when (or how often)
you wish your callback function to be called:
<pre>

  void  puSlider::setCBMode ( int mode ) ;
  float puSlider::getCBMode () ;
  
   where 'mode' is one of:
       PUSLIDER_CLICK  - Only invoke the callback when
                         the mouse goes in the active direction.
       PUSLIDER_DELTA  - Invoke the callback only when the value
                         of the slider changes by more than a
                         certain amount.
       PUSLIDER_ALWAYS - Invoke the callback all the time that
                         the mouse is in the widget with the mouse
                         button pushed down. (This is the default).

</pre>
In the PUSLIDER_DELTA case, the amount of change required before the callback
is called is set by:
<pre>

  void  puSlider::setDelta ( float f ) ;
  float puSlider::getDelta () ;

</pre>
The parameter is expressed as a fraction of the total slider width (ie
0.0f to 1.0f).
<pre>

  int  puSlider::isVertical () ;

</pre>
This returns TRUE for Vertical sliders - FALSE for Horizontal ones.
<a NAME="puDial"></a>
<h3>
puDial</h3>
<img SRC="puDial.png" ALT="view of puDial widget" height=127 width=188 align=RIGHT>The
puDial class is derived from puSlider and implements a square widget
with a circle inscribed in it. 
A radius of the circle is also drawn.  The value of the widget is
proportional to the angle the radius makes with the vertical
with straight down being zero - then winding it clockwise, straight up
is 0.5 and straight down again being 1.0. The constructor takes three
arguments: 
the coordinates of the lower left-hand corner of the widget and the widget
size:
<pre>

  puDial::puDial ( int minx, int miny, int sz ) ;

</pre>
By default, you can move the pointer directly from 0.0 to 1.0 or
1.0 to 0.0 without winding it all the way around the dial.  This
is called 'wrapping' the pointer.  If you need to change the wrap
mode, you can call:
<pre>

  void puDial::setWrap ( int wrapmode ) ;
  in   puDial::getWrap () ;

</pre>
Everything defined in the <a href="#puSlider">puSlider</a> API can also
be applied to puDial widgets.
<a NAME="puBiSlider"></a>
<h3>
puBiSlider</h3>
<img SRC="puBiSlider.png" ALT="view of puBiSlider widget" height=127 width=188 align=RIGHT>The
puBiSlider class implements a slider with two sliding boxes inside the
slider bar.  It is based on the <a href="#puSlider">puSlider</a> class,
meaning that anything you can do with a <a href="#puSlider">puSlider</a>
you can also do with a puBiSlider.  You define it with the following
call:
<pre>

  puBiSlider::puBiSlider ( int minx, int miny, int sz, int vertical = FALSE ) ;

</pre>
The puBiSlider differs from the puSlider in that the values of the slider
boxes are integers and you can set the minimum and maximum values that
they can take:
<pre>

  void puBiSlider::setMaxValue ( int i ) ;
  void puBiSlider::setMinValue ( int i ) ;

</pre>
Corresponding calls retrieve the minimum and maximum possible values:
<pre>

  int puBiSlider::setMaxValue ( void ) ;
  int puBiSlider::setMinValue ( void ) ;

</pre>
Since there are two sliding boxes, they are considered to be a current
minimum and current maximum value.  These are both integers and neither
one is stored in the "puValue" as the widget's value.  You set and
retrieve them with the following functions:
<pre>

  void puBiSlider::setCurrentMax ( int i ) ;
  void puBiSlider::setCurrentMin ( int i ) ;

  int  puBiSlider::getCurrentMax ( void ) ;
  int  puBiSlider::getCurrentMin ( void ) ;

</pre>
If the user clicks on the puBiSlider with his mouse, the box that is closer
to the mouse is activated and moves to the mouse position.  The other
box will stay put.  If the user drags the upper box over the lower
box or vice versa, the stationary box will move with the other box.
<p>
<a NAME="puTriSlider"></a>
<h3>
puTriSlider</h3>
<img SRC="puTriSlider.png" ALT="view of puTriSlider widget" height=227 width=108 align=RIGHT>The
puTriSlider class implements a slider with three sliding boxes inside the
slider bar.  It is based on the <a href="#puBiSlider">puBiSlider</a>
and includes everything that widget supports.  You define it with
the following call:
<pre>

  puTriSlider::puTriSlider ( int minx, int miny, int sz, int vertical = FALSE ) ; 

</pre>
The third box in the puTriSlider stores its value in the widget's value. 
You can set and retrieve the absolute minimum and maximum values that the
widget boxes can take, and you can set and retrieve the current minimum
and maximum values in the same way that you do with the puBiSlider. 
You can set and retrieve the value of the middle box by using the "<a href="#getValue">setValue</a>"
and "<a href="#getValue">getValue</a>" functions.
<p>
The puTriSlider has an additional option which allows you to freeze
the boxes on the ends of the slider bar.  The following functions
let you do this:
<pre>

   void puTriSlider::setFreezeEnds ( int val ) ;
   int  puTriSlider::getFreezeEnds () ;

</pre>
where "val" is either TRUE (the default) or FALSE.
<p>
<a NAME="puFrame"></a>
<h3>
puFrame</h3>
<img SRC="puFrame.png" ALT="view of puFrame widget" height=127 width=188 align=RIGHT>The
puFrame class is derived from <a href="#puObject">puObject</a>. It is designed
to provide some aesthetic layout and labelling to your user interface.
As such, the user can never do anything to the frame by clicking on it
- there is no point in creating a callback for this kind of object since
it will never be called. The frame renders as a large PUCOL_FOREGROUND
coloured rectangle (with legend and label) in the appropriate style.
<p>
puFrames have no special API - everything they need is in the <a href="#puObject">puObject</a>
API.
<p>
<a NAME="puText"></a>
<h3>
puText</h3>
<img SRC="puText.png" ALT="view of puText widget" height=127 width=188 align=RIGHT>The
puText class is derived from <a href="#puObject">puObject</a>. It's function
is simply to allow text to be positioned on the user interface. Since puText
has no active area (it cannot be clicked), it has no legend text and the
text you want it to draw should be in the label string.
<p>
The only special API for puText is its constructor function:
<pre>

  puText::puText ( int x, int y ) ;

</pre>
By default, this is the bottom-left corner of the label - but you can of
course change that with <a href="#puObject">puObject</a>::setLabelPlace().
<p>
Everything else that puText widgets need is in the <a href="#puObject">puObject</a>
API.
<p>
<a NAME="puInput"></a>
<h3>
puInput</h3>
<img SRC="puInput.png" ALT="view of puInput widget" height=127 width=188 align=RIGHT>The
puInput class is derived from <a href="#puObject">puObject</a>. It's designed
for the specific purpose of allowing the user to input a string (or an
integer or floating point number).
<p>
First, create the puInput object:
<pre>

   puInput::puInput ( int minx, int miny, int maxx, int maxy ) ;

</pre>
Note that puInput objects do not display their 'legend' string - the center
of the widget being used to draw the value as a string.
<p>
A puInput object can be in two states - accepting keystrokes - or ignoring
them. Use these functions to toggle between the two states:
<pre>

  void puInput::acceptInput () ;
  void puInput::rejectInput () ;
  int  puInput::isAcceptingInput () ;

</pre>
When the user hits the 'Return' key, the puInput is automatically set to
reject further input. When the user clicks the mouse onto the puInput,
it is automatically set to accept input - and the I-bar cursor is moved
next to the character nearest to where the mouse was clicked.
<p>
The text area contains an 'I' bar cursor and a highlighted 'select'
area. You can get and set the character positions (not pixel coordinates)
of those entities:
<pre>

  void puInput::setCursor ( int pos ) ;
  int  puInput::getCursor () ;

  void puInput::setSelectRegion ( int  start, int  end ) ;
  void puInput::getSelectRegion ( int *start, int *end ) ;

</pre>
Since a puInput uses the normal value getting and setting functions of
puObject, you are limited to PUSTRING_MAX characters (currently 80).
<p>
When typing into a puInput box, the Backspace, Delete, Home, End, Left
and Right Arrows, Space, Return, Tab, Esc and ^U keys have the expected
functions. All printable characters are inserted into the text. Everything
else is not accepted by the puInput and is available to other functions.
<p>
If you want to restrict the characters that the input widget will accept,
you use the following functions:
<pre>

  void  puInput::setValidData ( char *data ) ;  /* Sets list of valid characters to argument string */
  void  puInput::addValidData ( char *data ) ;  /* Appends argument string to list of valid characters */
  char *puInput::getValidData () ;              /* Returns pointer to list of valid characters */
  int   puInput::isValidCharacter ( char c ) ;  /* Returns 1 if character is valid and 0 if not */

</pre>
This will avoid, for example, the user typing his name into an input box
that is supposed to accept his birthdate.
<p>
If the text is too long to fit in the widget, only the rightmost
characters will be displayed. One space is always left to the right
of the text to give the user the impression that there is still room
to type.
<p>
<a NAME="puLargeInput"></a>
<h3>
puLargeInput</h3>
<img SRC="puLargeInput.png" ALT="view of puLargeInput widget" height=227 width=308 align=RIGHT>The
puLargeInput widget resembles the <a href="#puInput">puInput</a> widget
but it is actually based on the <a href="#puGroup">puGroup</a> widget. 
The reason for this is that the widget contains sub-widgets within it: 
there is <a href="#puFrame">puFrame</a> widget to display the text area;
two <a href="#puSlider">puSlider</a> widgets to allow the user to scroll
vertically and horizontally; and there are up to four <a href="#puArrowButton">puArrowButton</a>
widgets to allow rapid vertical scrolling.  The puLargeInput widget
allows the user to enter an arbitrarily large amount of text, including
multiple carriage returns.  This text is stored in a separate text
buffer and is not connected to the widget value.  You create a puLargeInput
widget with the following call:
<pre>puLargeInput::puLargeInput ( int x, int y, int w, int h, int arrows, int sl_width ) :</pre>
which creates a puLargeInput at location (x, y), with size (w, h), with
sliders of "sl_width" pixels wide, and with "arrows" pairs of up- and down-arrows
on the right-hand slider.  Allowed values for "arrows" are 0, 1, and
2.
<p>
The following functionality from the puInput widget is also implemented
in the puLargeInput widget:
<pre>

  void puLargeInput::acceptInput () ;
  void puLargeInput::rejectInput () ;
  int  puLargeInput::isAcceptingInput () ;

  void puLargeInput::setCursor ( int pos ) ;
  int  puLargeInput::getCursor () ;

  void puLargeInput::setSelectRegion ( int  start, int  end ) ;
  void puLargeInput::getSelectRegion ( int *start, int *end ) ;

  void  puLargeInput::setValidData ( char *data ) ;  /* Sets list of valid characters to argument string */
  void  puLargeInput::addValidData ( char *data ) ;  /* Appends argument string to list of valid characters */
  char *puLargeInput::getValidData () ;              /* Returns pointer to list of valid characters */
  int   puLargeInput::isValidCharacter ( char c ) ;  /* Returns 1 if character is valid and 0 if not */

</pre>
Besides the obvious methods of typing or erasing, you can add text to and
remove text from the widget using the following calls:
<pre>

  void  puLargeInput::setText ( char *l ) ;  /* Erases current text and copies input string to text */
  char *puLargeInput::getText ( void ) ;     /* Returns the pointer to the text string */
  void  puLargeInput::addNewLine ( char *l ) ;  /* Inserts input string at start of next line after cursor */
  void  puLargeInput::addText ( char *l ) ;  /* Inserts input string at cursor position */
  void  puLargeInput::appendText ( char *l ) ;  /* Adds input string to the end of text */
  void  puLargeInput::removeText ( int start, int end ) ;  /* Removes the text between character positions */

</pre>
The puLargeInput widget always stores a carriage return at the end of its
text.  Even if you delete all the text in the widget, it will create
an empty carriage return.
<p>
The puLargeInput widget also has a few other functions which may be
handy:
<pre>

  int  puLargeInput::getNumLines () ;  /* Returns the number of lines in the text */
  void puLargeInput::selectEntireLine ( void ) ;  /* Expands the select region to include full lines */
  void puLargeInput::setTopLineInWindow ( int val ) ;  /* Sets the top line to be displayed in the widget window */

</pre>
Additionally, you can let a puLargeInput widget reject all input, which is useful if you want to display some large amount of text without allowing the user to edit it:
<pre>

  void puLargeInput::enableInput () ;
  void puLargeInput::disableInput () ;
  int  puLargeInput::inputDisabled () ; /* Returns FALSE if the text can be modifed and TRUE if it can not */

</pre>
<a NAME="puGroup"></a>
<h3>
puGroup</h3>
The puGroup class is derived from <a href="#puObject">puObject</a>. When
declaring objects derived from puGroup, it is essential that these objects
be deleted in the reverse order to their creation (except when your program
is about to exit anyway).  This is because PUI keeps a list of puGroup
widgets on a stack, and attempting to delete a puGroup from the middle
of the stack will cause an error.
<p>
The purpose of a puGroup is allow you to group together other <a href="#puObject">puObject</a>s
and to operate on them en-masse.
<p>
When you want to create a group of <a href="#puObject">puObjects</a>
using a puGroup, you construct the puGroup itself, then construct all the
widgets that you want to have inside it. When you have finished adding
widgets to the puGroup, you call:
<pre>

  void puGroup::close () ;

</pre>
puGroup widgets can be placed inside other puGroup widgets to an arbitary
depth. When a puGroup is delete'ed, it will automatically delete everything
that it contains.
<p>
Doing a puObject::hide() on a puGroup will hide all the objects inside
the puGroup. Doing a puObject::greyout() on a puGroup prevents anything
inside that group from being clicked.
<p>
Colours, styles, etc are NOT propagated from puGroup to its children,
although there are four functions which allow you to change the
appearances of the child widgets on a per-child-class basis:
<pre>

  void puGroup::setChildStyle ( int childs, int style, int recursive = FALSE ) ;
  void puGroup::setChildBorderThickness ( int childs, int t, int recursive = FALSE ) ;
  void puGroup::setChildColour ( int childs, int which,
                                 float r, float g, float b, float a = 1.0f,
                                 int recursive = FALSE ) ;
  void puGroup::setChildColourScheme ( int childs,
                                       float r, float g, float b, float a = 1.0f,
                                       int recursive = FALSE ) ;

</pre>
These routines all take a bitmask specifying which childs to apply
the specifed value(s) for by or-ing the appropiate PUCLASS_ constants as
their first argument.
<p>
The last parameter specifies whether the function should operate
recursively, meaning that if a child of the puGroup is another puGroup
object or a widget derived from puGroup, the attributes of the widgets
in this group are also changed.
<p>
Have a look at the following example (assume inputbox to be a pointer to
a <a href="#puLargeInput">puLargeInput</a> widget, which is derived from puGroup and contains
a <a href="#puFrame">puFrame</a>, two <a href="#puSlider">puSlider</a> and up to four <a href="#puArrowButton">puArrowButton</a> widgets):
<pre>

  inputbox -> setChildStyle ( PUCLASS_ARROW, PUSTYLE_BOXED ) ;
  inputbox -> setChildColour ( PUCLASS_ARROW | PUCLASS_FRAME,
                             PUCOL_HIGHLIGHT, 1.0, 1.0, 1.0 ) ;

</pre>
In this case, we would have set the style of all arrow button subwidgets
(if there were any) to PUSTYLE_BOXED and specifed the "highlight"
colour of both the frame and the arrow button subwidgets to be white.
<p>
Note that when you specify a child class in the bitmask, all childs
derived from that class are also affected. Thus, using PUCLASS_OBJECT
as the first argument of these functions is an easy way to change the
parameters of all child widgets.
<p>
The coordinates of puGroup child objects are always specified relative
to the bottom-left corner of the puGroup rather than in absolute screen
coordinates.
<p>
The puGroup widget is not drawn.  It is commonly a good thing to
do, but certainly not essential, to make the first widget inside a puGroup
to be a <a href="#puFrame">puFrame</a> of the group's desired size. 
The frame will provide a background for all the other widgets in the group.
<a NAME="puInterface"></a>
<h3>
puInterface</h3>
The puInterface class is derived from <a href="#puGroup">puGroup</a>. This
class is another abstract class - application programs should not declare
puInterface objects.
<p>
The difference between a simple puGroup and a puInterface is that when
an interface is enabled, it takes priority over other widgets so that they
cannot be clicked upon. Widgets such as popup menus are typically puInterfaces
which group a number of
<a href="#puButton">puButtons</a>.
<p>
The PUI system itself maintains a private global puInterface which is
used to group together all of the <a href="#puObject">puObjects</a> that
the application generates that are not grouped into other puInterfaces.
<a NAME="puButtonBox"></a>
<h3>
puButtonBox</h3>
<img SRC="puButtonBox.png" ALT="view of puButtonBox widget" height=127 width=188 align=RIGHT>The
puButtonBox class is derived from <a href="#puInterface">puInterface</a>.
It is designed to automatically generate a number of 'radio' buttons with
a handful of member function calls and a single callback function. It can
optionally manage the problem of ensuring that exactly one of the buttons
is depressed at all times, or it can allow multiple buttons to be active
at the same time.
<pre>

  puButtonBox::puButtonBox ( int minx, int miny, int maxx, int maxy,
                             char **labels, int one_button ) ;

</pre>
The 'labels' parameter is a NULL-terminated array of pointers-to-strings
containing the labels for each of the radio-buttons. These are drawn in
order from top to bottom of the Button Box.
<p>
Like most other puObjects, puButtonBox has a 'value' that can be set
using puObject::setValue(int i) and read using puObject::getValue(). If
'one_button' is set TRUE then the puButtonBox will use its value as the
index of the radio-button that is currently pressed. If 'one_button' is
FALSE then the puButtonBox will limit the number of buttons to 32 and use
its value as a mask indicating which buttons are set ('1'==button pressed,
'0'==button not pressed).
<pre>

  int puButtonBox::isOneButton () ;

</pre>
This function returns TRUE for a one_button box, FALSE otherwise.
<p>
By default, if one_button==TRUE then the first button is highlighted
since the 'value' of the puButtonBox is zero. If one_button==FALSE then
none of the buttons are pressed by default since the value is 0x00000000
and that indicates no buttons pushed.
<p>
In the one_button==TRUE case, setting the value to something out of
range will result in none of the radio buttons being highlighted.
<p>
<a NAME="puPopup"></a>
<h3>
puPopup</h3>
The puPopup class is derived from <a href="#puInterface">puInterface</a>.
Its function is to pop up a bunch of other widgets on command.
<p>
One significant difference between puPopups and other puObjects is that
it starts off hidden (puObject::isVisible()==FALSE) - and the application
(or some other widget) has to make it visible in order for it to DO something.
<p>
It's possible to use a puPopup to create a popup menu, as a part of
a drop-down menu and to implement dialog boxes and alert boxes.
<p>
<a NAME="puDialogBox"></a>
<h3>
puDialogBox</h3>
<img SRC="puDialogBox.png" ALT="view of example puDialogBox widget group" height=127 width=188 align=RIGHT>The
puDialogBox class is derived from <a href="#puPopup">puPopup</a>. While
there is a puDialogBox in existence (ie Constructed and not yet destroyed)
nothing that isn't contained within that puDialogBox will be activated
by either keyboard or mouse (Although they will still be re-drawn).
<pre>

   puDialogBox::puDialogBox ( int x, int y ) ;

</pre>
Here is a simple example where a callback function wants to tell the user
that its code hasn't been written yet...
<pre>

<a href="#puDialogBox">puDialogBox *dialog_box = NULL ; </a>

void go_away_callback ( puObject * )
{
  delete dialog_box ;
  dialog_box = NULL ;
}

void make_dialog ( char *txt )
{
  if ( dialog_box != NULL )
    return ;

  <a href="#puDialogBox">dialog_box = new puDialogBox ( 50, 50 ) ;
</a>  {
    <a href="#puFrame">new puFrame ( 0, 0, 400, 100 ) ;
</a>    <a href="#puText">new puText  ( 10, 70 ) -> setLabel ( txt ) ;

</a>    <a href="#puOneShot">puOneShot *ok = new puOneShot ( 180, 10, "OK" ) ;
    ok -> makeReturnDefault ( TRUE ) ;
    ok -> setCallback       ( go_away_callback ) ;
</a>  }
  <a href="#puDialogBox">dialog_box -> close  () ;
  dialog_box -> reveal () ;
</a>}

void not_implemented_yet_callback ( <a href="#puObject">puObject</a> * )
{
  make_dialog ( "Sorry, that function isn't implemented yet" ) ;
}

</pre>
When 'not_implemented_yet_callback' is called (presumably from another
puObject), it calls 'make_dialog' to construct and activate a suitable
dialog box object.
<p>
This causes the dialog box to pop up onto the screen. When the 'OK'
button is pressed (or the RETURN key is hit - since the button has makeReturnDefault(TRUE)
set), the 'go_away_callback' is called - which deletes the dialog box (which
in turn causes the destruction of all the contents of that box).
<p>
<a NAME="puPopupMenu"></a>
<h3>
puPopupMenu</h3>
<img SRC="puPopupMenu.png" ALT="view of puPopupMenu widget" height=127 width=88 align=RIGHT>The
puPopupMenu class is derived from <a href="#puPopup">puPopup</a>. It's
designed for the specific purpose of building a simple popup menu - which
is actualy implemented as a stack of buttons (puOneShot's actually) with
callbacks.
<p>
To create the puPopupMenu object:
<pre>

   puPopupMenu::puPopupMenu ( int x, int y, char *legends[], puCallback cb[] ) ;

</pre>
The individual items in the menu are set up in a pair of NULL-terminated
arrays. The 'legends' array lists the strings that will appear in the menu
and the 'cb' array is the corresponding callback that will be made if that
menu item is clicked. (Both arrays should be NULL terminated but the puCallback
array can have other NULL pointers indicating items that have no action
when clicked upon).
<p>
Each item that you add will be translated into an appropriately sized,
styled and coloured puOneShot (which is only visible to the application
when passed to the callback function).
<p>
<a NAME="puMenuBar"></a>
<h3>
puMenuBar</h3>
<img SRC="puMenuBar.png" ALT="view of puMenuBar widget" height=227 width=188 align=RIGHT>The
puMenuBar class is derived from <a href="#puInterface">puInterface</a>.
It's designed for the specific purpose of building a horizontal strip menu
(typically at the top of the screen). Each entry in that menu turns into
a <a href="#puPopupMenu">puPopupMenu</a> when clicked upon.
<p>
First, create the puMenuBar object:
<pre>

   puMenuBar::puMenuBar () ;
   puMenuBar::puMenuBar ( int y ) ;

</pre>
(If you omit 'y', the menu bar will attempt to remain at the top of the
screen, even if the screen is resized).
<p>
Next, set up the colours for the menu - just as with any other puObject,
then add the individual items:
<pre>

  void *puMenuBar::add_submenu ( char *name, char *legends[], puCallback cb[] );

</pre>
'name' is the name that appears on the menu bar, 'legends' is the NULL-terminated
list of strings that appear inside the popup menu and 'cb' is the list
of corresponding callback functions. (Both arrays should be NULL terminated
but the puCallback array can have other NULL pointers indicating PopupMenu
items that have no action when clicked upon).
<p>
Each item that you add will be translated into an appropriately sized,
styled and coloured puPopupMenu which is hidden and revealed appropriately
as each name is clicked upon.
<p>
Don't forget (since this is a kind of puInterface) that you need to
call:
<pre>

  puMenuBar::close() ;

</pre>
...when you have finished creating the menu items.
<p>
Example:
<pre>

  char      *file_submenu    [] = { "Exit" , "Close", "--------", "Save" , NULL};
  puCallback file_submenu_cb [] = { exit_cb, cull_cb,       NULL, save_cb, NULL};
  char      *help_submenu    [] = { "About...", "Help" , NULL } ;
  puCallback help_submenu_cb [] = { about_cb  , help_cb, NULL } ;

  puMenuBar *menu = new puMenuBar ( -1 ) ;
  menu->add_submenu ( "File", file_submenu, file_submenu_cb ) ;
  menu->add_submenu ( "Help", help_submenu, help_submenu_cb ) ;
  menu->close () ;

</pre>
<a NAME="puVerticalMenu"></a>
<h3>
puVerticalMenu</h3>
<img SRC="puVerticalMenu.png" ALT="view of puVerticalMenu widget" height=90 width=81 align=RIGHT>The
puVerticalMenu is derived from the <a href="#puGroup">puGroup</a> class
and is designed to create a menu with its entries one above the other. 
You create it with the following call:
<pre>

  puVerticalMenu::puVerticalMenu ( int x = -1, int y = -1 ) ;

</pre>
where using a default value for "x" will place the menu on the left-hand
side of its window and using a default value for "y" will place it on the
top of its window.  Its behavior is essentially the same as that of
the <a href="#puMenuBar">puMenuBar</a> widget.
<p>
<a NAME="puListBox"></a>
<h3>
puListBox</h3>
The puListBox widget is a multiple-line text widget which was designed
to support the <a href="#puFileSelector">puFileSelector</a> widget.  It
is derived from the <a href="#puButton">puButton</a> widget and supports
that widget's entire API.  You create a puListBox by invoking the
contructor method:
<pre>

  puListBox::puListBox  ( int minx, int miny, int maxx, int maxy,
                          char **list = NULL) ;

</pre>
In this case "list" is a null-terminated array of character strings that
contain the items that go into the list box.  You are responsible
for supplying this array and for making sure that it is still around the
entire time the puListBox widget is using it.  The widget does <u>not</u>
make its own copy of the array.  You can change which array the listbox
operates on by calling:
<pre>

  puListBox::newList ( char **list ) ;

</pre>
The puListBox widget supports three additional function calls in its
API.  They are as follows:
<pre>

  int  puListBox::getNumItems () ;  /* Return the number of items in the list */
  int  puListBox::getTopItem  () const ;  /* Return the index of the top item that is displayed in the list */
  void puListBox::setTopItem  ( int item_index ) ;  /* Set the index of the top item to be displayed */

</pre>
If the text is too wide for the box, it'll be truncated with "..." displayed
to the right of it to show the user that there is some missing text.
<a NAME="puFilePicker"></a>
<h3>
puFilePicker</h3>
puFilePicker is now obsolete. Please use puFileSelector instead.
<a NAME="puFileSelector"></a>
<h3>
puFileSelector</h3>
<img SRC="puFileSelector.png" ALT="view of puFileSelector widget" height=227 width=308 align=RIGHT>The
puFileSelector class is derived from <a href="#puDialogBox">puDialogBox</a>.
FileSelector creates a dialog box for selecting a file.  The puFileSelector
widget contains:
<ul>
<li>A <a href="#puText">puText</a> widget for some text at the top of
    the dialog box.
<li>A <a href="#puListBox">puListBox</a> widget for listing the files.
<li>A <a href="#puSlider">puSlider</a> widget with zero, two, or four
    <a href="#puArrowButton">puArrowButton</a> widgets (depending
    on what you ask for) to scroll the file list.
<li>A two <a href="#puOneShot">puOneShot</a> button widgets for
    the OK and Cancel buttons.
<li>A <a href="#puInput">puInput</A> to allow the user to type
    in the filename by hand.
</ul>
The API for puFileSelector:
<pre>

  puFileSelector::puFileSelector ( int x, int y,
                                   const char *dir,
                                   const char *title = "Pick a file" ) ;
  puFileSelector::puFileSelector ( int x, int y, int arrows,
                                   const char *dir,
                                   const char *title = "Pick a file" ) ;
  puFileSelector::puFileSelector ( int x, int y, int w, int h,
                                   const char *dir,
                                   const char *title = "Pick a file" ) ;
  puFileSelector::puFileSelector ( int x, int y, int w, int h, int arrows,
                                   const char *dir,
                                   const char *title = "Pick a file" ) ;

</pre>
The first constructor sets the possition but uses a default value for the
size of the dialog box, currently defaulting to 170,220.  The second
is like the first but also allows you to specify up- and down-arrows (0
for none, 1 for single arrows, 2 for single and double arrows) next to
the list box.  The third and fourth constructors allow you to also
select the size of the dialog box as well.
<p>
The "dir" argument is the name of the directory whose files are to
be listed as a starting point - it can be either absolute or relative
to the current working directory.
<p>
"title" is a title that is displayed in the puFileSelector widget.
<p>
When a file has been picked by the user, the string value of the widget will
be set to the absolute pathname of the file.
<pre>

  puFileSelector::setSize ( int w, int h) ;

</pre>
This method is used to set the current width and height of the dialog box.
<p>
<pre>

  puFileSelector::setInitialValue ( char *pathname ) ;

</pre>
Sets the initial value within the type-in area of the widget.  This
is generally a simple file name - but it could be a full path
either relative to the 'dir' you specified in the constructor or
or an absolute path.
<h2>
Non-Class Functions.</h2>
The following functions are not a part of any classes:
<p>
<a NAME="puSetDefaults"></a>
<h3>
Setting Defaults</h3>
It can be pretty tedious coding in the colours, fonts and style for every
puObject. There are a number of routines that alter the defaults that will
be assumed for all subsequently constructed puObjects...
<pre>  void puSetDefaultStyle ( int style ) ;
  int  puGetDefaultStyle () ;

  void   puSetDefaultFonts ( puFont  legendFont, puFont  labelFont ) ;
  void   puGetDefaultFonts ( puFont *legendFont, puFont *labelFont ) ;
  puFont puGetDefaultLabelFont  () ;
  puFont puGetDefaultLegendFont () ;

  void puSetDefaultColourScheme ( float  r, float  g, float  b, float  a = 1.0 );
  void puGetDefaultColourScheme ( float *r, float *g, float *b, float *a = NULL);

</pre>
These take the same arguments as the corresponding puObject class members.
<p>
<a NAME="puInit"></a>
<h3>
puInit</h3>
This must be the first PUI function that you call. It must be called after
GLUT window setup but before glutMainLoop().
<pre>

   void puInit () ;

</pre>
<a NAME="puDisplay"></a>
<h3>
puDisplay</h3>
Causes PUI to redraw all of the currently created widgets (in a particular
window in case of second one).
<pre>

   void puDisplay () ;
   void puDisplay ( int window_number ) ;

</pre>
It sets up the GL transforms as follows:
<pre>

  int w = puGetWindowWidth  () ;
  int h = puGetWindowHeight () ;

  glPushAttrib   ( GL_ENABLE_BIT | GL_VIEWPORT_BIT | GL_TRANSFORM_BIT ) ;

  glDisable      ( GL_LIGHTING   ) ;
  glDisable      ( GL_FOG        ) ;
  glDisable      ( GL_TEXTURE_2D ) ;
  glDisable      ( GL_DEPTH_TEST ) ;

  glViewport     ( 0, 0, w, h ) ;
  glMatrixMode   ( GL_PROJECTION ) ;
  glPushMatrix   () ;
  glLoadIdentity () ;
  gluOrtho2D     ( 0, w, 0, h ) ;
  glMatrixMode   ( GL_MODELVIEW ) ;
  glPushMatrix   () ;
  glLoadIdentity () ;</pre>
...and after it finishes rendering the GUI and the puCursor (see below),
it restores state like this:
<pre>  glMatrixMode   ( GL_PROJECTION ) ;
  glPopMatrix    () ;
  glMatrixMode   ( GL_MODELVIEW ) ;
  glPopMatrix    () ;
  glPopAttrib    () ;

</pre>
All drawing code is done with whatever glMaterial/glTexture/glEnabled facilities
are curently set. All PUI rendering is done with simple colours and 2D
drawing functions such as glRect and glDrawPixels.
<p>
This function is typically called from the glutDisplayFunc callback.
<p>
Example:
<pre>

  void my_display_func ()
  {
    glClearColor ( 0.1, 0.4, 0.1, 1.0 ) ;
    glClear      ( GL_COLOR_BUFFER_BIT ) ;
    ...do your own OpenGL rendering...
    <a href="#puDisplay">puDisplay () ;
</a>    glutSwapBuffers   () ;
    glutPostRedisplay () ;
  }
 
  .
  .
  <a href="#puInit">puInit () ;
</a>  glutDisplayFunc ( my_display_func ) ;
  .
  .
  glutMainLoop() ;

</pre>
<a NAME="puDeleteObject"></a>
<h3>
puDeleteObject</h3>
You should use this routine instead of deleting widgets directly.
<pre>

   void puDeleteObject ( puObject *ob ) ;

</pre>
<a NAME="puKeyboard"></a>
<h3>
puKeyboard</h3>
This routine takes keystroke events (presumably generated by GLUT) and
uses them to decide which (if any) widgets changed state as a result. puKeyboard
doesn't do any actual graphics - so you have to call <a href="#puDisplay">puDisplay</a>
if you want the display to be upated.
<pre>

   int puKeyboard ( int key, int state ) ;

   'key' is either an ASCII character, or one of the
       PU_KEY_xxx symbols. These are named similarly
       to the GLUT_KEY_xxx symbols but are numerically
       set such that:

           PU_KEY_xxx == GLUT_KEY_xxx + PU_KEY_GLUT_SPECIAL_OFFSET
   'state' is one of
       PU_DOWN           (which is the same as GLUT_DOWN)
       PU_UP             (which is the same as GLUT_UP)
       (At present, GLUT can only generate PU_DOWN events for the
       keyboard - and PUI won't do anything with PU_UP events.

</pre>
Notice that this function will accept either an ASCII character or a special
keycode.
<p>
The return result is TRUE if one of the widgets actually used the keystroke.
This can be used to determine if the keyboard event was 'consumed' by the
user interface - or whether it should be used in some other application-specific
way. It is also true to say that in a single-buffered application, the
<a href="#puDisplay">puDisplay</a>
function doesn't need to be called until puKeyboard() returns TRUE (unless
of course the application chooses to change a colour or a label or something).
<p>
Example:
<pre>

   void my_keyboard_func ( unsigned char key, int x, int y )
   {
     puKeyboard ( key, PU_DOWN ) ;
     glutPostRedisplay () ;
   }
 
   void my_special_func ( int special_key, int x, int y )
   {
     puKeyboard ( special_key + PU_KEY_GLUT_SPECIAL_OFFSET, PU_DOWN ) ;
     glutPostRedisplay () ;
   }
 
   .
   .
   <a href="#puInit">puInit () ;
</a>   glutKeyboardFunc ( my_keyboard_func ) ;
   glutSpecialFunc  ( my_special_func  ) ;
   .
   .
   glutMainLoop() ;

</pre>
Note: PU_KEY_GLUT_SPECIAL_OFFSET is required since the definitions of the
GLUT_KEY_xxx symbols overlap the ASCII character range but the PU_KEY_xxx
symbols don't. Hence PU_KEY_GLUT_SPECIAL_OFFSET is currently defined to
be 256.
<p>
These are the code symbols for the special keys:
<pre>

    PU_KEY_F1       PU_KEY_F2         PU_KEY_F3     PU_KEY_F4
    PU_KEY_F5       PU_KEY_F6         PU_KEY_F7     PU_KEY_F8
    PU_KEY_F9       PU_KEY_F10        PU_KEY_F11    PU_KEY_F12

    PU_KEY_LEFT     PU_KEY_UP         PU_KEY_RIGHT  PU_KEY_DOWN
    PU_KEY_PAGE_UP  PU_KEY_PAGE_DOWN  PU_KEY_HOME   PU_KEY_END
    PU_KEY_INSERT

</pre>
<a NAME="puMouse"></a>
<h3>
puMouse</h3>
This routine take mouse events (presumably generated by GLUT) and uses
them to decide which (if any) widgets changed state as a result. puMouse
doesn't do any actual graphics - so you have to call <a href="#puDisplay">puDisplay</a>
if you want the display to be upated.
<pre>

   int puMouse ( int buttons, int state, int x, int y ) ;
   int puMouse ( int x, int y ) ;

   'buttons' is one of
       PU_LEFT_BUTTON    (which is the same as GLUT_LEFT_BUTTON)
       PU_MIDDLE_BUTTON  (which is the same as GLUT_MIDDLE_BUTTON)
       PU_RIGHT_BUTTON   (which is the same as GLUT_RIGHT_BUTTON)
   'state' is one of
       PU_DOWN           (which is the same as GLUT_DOWN)
       PU_UP             (which is the same as GLUT_UP)

</pre>
Notice that this function will accept exactly the arguments that GLUT passes
to the glutMouseFunc, glutMotionFunc and glutPassiveMotionFunc callbacks.
This means that the 'y' coordinate is reversed compared to those used in
OpenGL. The coordinate is flipped back inside the function before comparing
it to the active areas of all the widgets.
<p>
Since GLUT doesn't tell you which mouse buttons are held while the mouse
is being 'dragged', the second form of the 'puMouse' function (which is
usually called from the glutMotionFunc and glutPassiveMotionFunc callbacks),
assumes that the mouse buttons are the same as for the last call to the
first form of the puMouse() call (which <b>does</b> have button information).
<p>
The return result is TRUE if one of the widgets was actually hit by
the mouse event. This can be used to determine if the mouse event was 'consumed'
by the user interface - or whether it should be used in some other application-specific
way. It is also true to say that in a single-buffered application, the
<a href="#puDisplay">puDisplay</a>
function doesn't need to be called until puMouse() returns TRUE (unless
of course the application chooses to change a colour or a label or something).
<a NAME="puShowCursor"></a>
<h3>
The PUI 'soft' Cursor</h3>
PUI can take motion events (presumably generated by GLUT - and passed on
to puMouse) and use them to draw a mouse cursor. Typically, the underlying
window manager will draw a perfectly good cursor for you - but there are
a few (rare) cases where such facilities are not available and a cursor
drawn using OpenGL is needed.
<p>
It is also possible to show and hide the PUI cursor (note that it is
hidden by default):
<pre>

   void puShowCursor     () ;
   void puHideCursor     () ;
   int  puCursorIsHidden () ;

</pre>
The cursor is always drawn in black, with a white border - it is about
18 pixels wide and 18 pixels high and is drawn as an arrow pointing north-west.
At present, there is no way to change the cursor shape or colour.
<p>
If you enable this function on a machine that does have a hardware (or
at least operating-system generated) cursor, then you will probably notice
that the PUI cursor lags behind the 'real' cursor. This is because the
PUI cursor can only be drawn at the end of the frame, after all the other
OpenGL drawing functions are complete. Also, if you are using a double-buffered
rendering context, the cursor won't appear in it's new position until the
buffers are swapped at the end of the frame.
<p>
Still, for all its faults, if there is no other cursor provided for
you - PUI's cursor is a lot better than nothing.
<h3>
Example of puMouse and puShowCursor usage:</h3>
Example:
<pre>

   void my_mouse_func ( int button, int updown, int x, int y )
   {
     <a href="#puMouse">puMouse ( button, updown, x, y ) ;
</a>     glutPostRedisplay () ;
   }
 
   void my_motion_func ( int x, int y )
   {
     <a href="#puMouse">puMouse ( x, y ) ;
</a>     glutPostRedisplay () ;
   }
  .
  . 
  <a href="#puInit">puInit () ;

</a>  glutMouseFunc         ( my_mouse_func  ) ;
  glutMotionFunc        ( my_motion_func ) ;
  glutPassiveMotionFunc ( my_motion_func ) ;

  if ( my_hardware_doesnt_have_a_cursor )
    <a href="#puShowCursor">puShowCursor () ;
</a>  .
  .
  glutMainLoop () ;

</pre>
<a NAME="ActiveWidgetFunctions"></a>
<h3>
Active Widget Functions</h3>
PUI has three functions which you can use to manipulate the active widget. 
Here they are:
<pre>

  void puDeactivateWidget () ;  /* Sets the Active Widget to NULL */
  void puSetActiveWidget ( puObject *w ) ;  /* Sets the Active Widget */
  puObject *puActiveWidget () ;  /* Returns the active widget */

</pre>

<p>
<a NAME="CutAndPaste"></a>
<h3>
Cut and Paste</h3>
You can cut and paste text between different puInput widgets and puLargeInput
widgets.  The cut, copy, and paste commands are the standard CTRL-X,
CTRL-C, and CTRL-V.
<h2>
Miscellany</h2>
<a href="mailto:mdanks@Stormfront.com">Mark Danks</a> has succeeded in getting PUI to function in a WIN32 environment
without using GLUT. This is certainly not the intended way to use PUI -
even under WIN32 - but it's interesting to know that it
<b>is</b> possible.
<p>
In fact, this neatly demolishes my hope that people would write their
WIN32 programs in GLUT/OpenGL/PUI and thus be able to port them over to
Linux at near zero effort.
<p>
Mark's changes are now in mainstream PUI, all you have to do is to compile
the PUI sources with:
<pre>

      -DPU_NOT_USING_GLUT

</pre>
Since there is no longer any way for PUI to glutGet() the screen dimensions,
your application must now tell PUI every time it changes the screen dimensions.
<pre>

    puSetWindowSize ( int width, int height ) ;

</pre>
There are two portability functions:
<pre>

   int puGetWindowWidth  () ;
   int puGetWindowHeight () ;

</pre>
These return the most recent puSetWindowSize parameters under Marks raw
WIN32 environment - and do a nice portable glutGet() on all other setups.
<p>
The GLUT-less PUI cannot switch fonts - it always uses the system font.
It also requires the 'wgl' functions to be present in whichever OpenGL
is being used.
<p>
There is a demo of this PUI setup in the puiAlone directory. Notice
that this code is provided under somewhat different terms from the remainder
of PUI - nothing too onerous though.
<hr>
<address>
<a href="http://web2.airmail.net/sjbaker1">Steve J. Baker.</a> &lt;<a href="mailto:sjbaker1@airmail.net">sjbaker1@airmail.net</a>></address>

</body>
</html>
